import { create } from "zustand";
import { immer } from "zustand/middleware/immer";
import { subscribeWithSelector } from "zustand/middleware";
import { temporal } from "zundo";
import type { Animation, Deck, DeckTheme, Slide, SlideElement } from "@/types/deck";
import type { FileSystemAdapter } from "@/adapters/types";
import { nextElementId } from "@/utils/id";
import { assert } from "@/utils/assert";

// Module-level adapter reference, set by App when adapter is created
let _adapter: FileSystemAdapter | null = null;
export function setStoreAdapter(adapter: FileSystemAdapter | null) {
  _adapter = adapter;
}

interface DeckState {
  currentProject: string | null;
  deck: Deck | null;
  currentSlideIndex: number;
  selectedSlideIds: string[];
  selectedElementIds: string[];
  highlightedElementIds: string[];
  isDirty: boolean;
  isSaving: boolean;

  openProject: (project: string, deck: Deck) => void;
  closeProject: () => void;
  loadDeck: (deck: Deck) => void;
  replaceDeck: (deck: Deck) => void;
  saveToDisk: () => Promise<void>;
  setCurrentSlide: (index: number) => void;
  setSelectedSlides: (ids: string[]) => void;
  nextSlide: () => void;
  prevSlide: () => void;
  selectElement: (id: string | null, mode?: "replace" | "add" | "toggle") => void;
  updateElement: (slideId: string, elementId: string, patch: Partial<SlideElement>) => void;
  updateSlide: (slideId: string, patch: Partial<Slide>) => void;
  addSlide: (slide: Slide, afterIndex?: number) => void;
  deleteSlide: (slideId: string) => void;
  moveSlide: (fromIndex: number, toIndex: number) => void;
  addElement: (slideId: string, element: SlideElement) => void;
  deleteElement: (slideId: string, elementId: string) => void;
  duplicateElement: (slideId: string, elementId: string) => void;
  addAnimation: (slideId: string, animation: Animation) => void;
  updateAnimation: (slideId: string, index: number, patch: Partial<Animation>) => void;
  deleteAnimation: (slideId: string, index: number) => void;
  moveAnimation: (slideId: string, fromIndex: number, toIndex: number) => void;
  updateTheme: (patch: Partial<DeckTheme>) => void;
  toggleSlideHidden: (slideId: string) => void;
  highlightElements: (ids: string[]) => void;
  patchElementById: (elementId: string, patch: Partial<SlideElement>) => void;
  bringToFront: (slideId: string, elementId: string) => void;
  sendToBack: (slideId: string, elementId: string) => void;
}

let highlightTimer: ReturnType<typeof setTimeout> | null = null;
let isDragging = false;

// Hoisted so we can cancel the pending batch on project switch
let batchTimeout: ReturnType<typeof setTimeout> | null = null;
// eslint-disable-next-line @typescript-eslint/no-explicit-any
let batchStartState: any = null;

export function setDeckDragging(active: boolean) {
  isDragging = active;
}

function getSlide<T extends { id: string }>(slides: T[], slideId: string): T {
  const slide = slides.find((s) => s.id === slideId);
  assert(slide !== undefined, `Slide ${slideId} not found`);
  return slide;
}

export const useDeckStore = create<DeckState>()(
  subscribeWithSelector(
    temporal(
      immer((set, get) => ({
        currentProject: null,
        deck: null,
        currentSlideIndex: 0,
        selectedSlideIds: [],
        selectedElementIds: [],
        highlightedElementIds: [],
        isDirty: false,
        isSaving: false,

        openProject: (project, deck) =>
          set((state) => {
            state.currentProject = project;
            state.deck = deck;
            state.currentSlideIndex = 0;
            state.selectedSlideIds = deck.slides.length > 0 ? [deck.slides[0]!.id] : [];
            state.selectedElementIds = [];
            state.isDirty = false;
          }),

        closeProject: () =>
          set((state) => {
            state.currentProject = null;
            state.deck = null;
            state.currentSlideIndex = 0;
            state.selectedSlideIds = [];
            state.selectedElementIds = [];
            state.isDirty = false;
          }),

        loadDeck: (deck) =>
          set((state) => {
            state.deck = deck;
            state.currentSlideIndex = 0;
            state.selectedSlideIds = deck.slides.length > 0 ? [deck.slides[0]!.id] : [];
            state.selectedElementIds = [];
            state.isDirty = false;
          }),

        replaceDeck: (deck) =>
          set((state) => {
            state.deck = deck;
            // Clamp slide index if slides were removed
            if (state.currentSlideIndex >= deck.slides.length) {
              state.currentSlideIndex = Math.max(0, deck.slides.length - 1);
            }
            state.isDirty = true;
          }),

        saveToDisk: async () => {
          const { deck, isSaving, currentProject } = get();
          if (!deck || isSaving || !currentProject || !_adapter) return;
          set((state) => { state.isSaving = true; });
          await _adapter.saveDeck(deck);
          set((state) => { state.isSaving = false; state.isDirty = false; });
        },

        setCurrentSlide: (index) =>
          set((state) => {
            assert(state.deck !== null, "No deck loaded");
            assert(index >= 0 && index < state.deck.slides.length, `Slide index ${index} out of bounds`);
            state.currentSlideIndex = index;
            state.selectedSlideIds = [state.deck.slides[index]!.id];
            state.selectedElementIds = [];
          }),

        setSelectedSlides: (ids) =>
          set((state) => {
            state.selectedSlideIds = ids;
          }),

        nextSlide: () =>
          set((state) => {
            if (!state.deck) return;
            if (state.currentSlideIndex < state.deck.slides.length - 1) {
              state.currentSlideIndex += 1;
              state.selectedSlideIds = [state.deck.slides[state.currentSlideIndex]!.id];
              state.selectedElementIds = [];
            }
          }),

        prevSlide: () =>
          set((state) => {
            if (!state.deck) return;
            if (state.currentSlideIndex > 0) {
              state.currentSlideIndex -= 1;
              state.selectedSlideIds = [state.deck.slides[state.currentSlideIndex]!.id];
              state.selectedElementIds = [];
            }
          }),

        selectElement: (id, mode = "replace") =>
          set((state) => {
            if (mode === "replace") {
              state.selectedElementIds = id ? [id] : [];
            } else if (mode === "add") {
              if (id && !state.selectedElementIds.includes(id)) {
                state.selectedElementIds.push(id);
              }
            } else {
              // toggle
              if (!id) return;
              const idx = state.selectedElementIds.indexOf(id);
              if (idx === -1) {
                state.selectedElementIds.push(id);
              } else {
                state.selectedElementIds.splice(idx, 1);
              }
            }
          }),

        updateElement: (slideId, elementId, patch) =>
          set((state) => {
            assert(state.deck !== null, "No deck loaded");
            const slide = getSlide(state.deck.slides, slideId);
            const element = slide.elements.find((e) => e.id === elementId);
            assert(element !== undefined, `Element ${elementId} not found in slide ${slideId}`);
            Object.assign(element, patch);
            state.isDirty = true;
          }),

        patchElementById: (elementId, patch) =>
          set((state) => {
            assert(state.deck !== null, "No deck loaded");
            for (const slide of state.deck.slides) {
              const element = slide.elements.find((e) => e.id === elementId);
              if (element) {
                Object.assign(element, patch);
                state.isDirty = true;
                return;
              }
            }
          }),

        updateSlide: (slideId, patch) =>
          set((state) => {
            assert(state.deck !== null, "No deck loaded");
            const slide = getSlide(state.deck.slides, slideId);
            Object.assign(slide, patch);
            state.isDirty = true;
          }),

        addSlide: (slide, afterIndex) =>
          set((state) => {
            assert(state.deck !== null, "No deck loaded");
            const idx = afterIndex ?? state.deck.slides.length;
            state.deck.slides.splice(idx + 1, 0, slide);
            state.isDirty = true;
          }),

        deleteSlide: (slideId) =>
          set((state) => {
            assert(state.deck !== null, "No deck loaded");
            const idx = state.deck.slides.findIndex((s) => s.id === slideId);
            assert(idx !== -1, `Slide ${slideId} not found`);
            state.deck.slides.splice(idx, 1);
            state.selectedSlideIds = state.selectedSlideIds.filter((id) => id !== slideId);
            if (state.currentSlideIndex >= state.deck.slides.length) {
              state.currentSlideIndex = Math.max(0, state.deck.slides.length - 1);
            }
            state.isDirty = true;
          }),

        moveSlide: (fromIndex, toIndex) =>
          set((state) => {
            assert(state.deck !== null, "No deck loaded");
            const slides = state.deck.slides;
            assert(fromIndex >= 0 && fromIndex < slides.length, `fromIndex ${fromIndex} out of bounds`);
            assert(toIndex >= 0 && toIndex < slides.length, `toIndex ${toIndex} out of bounds`);
            const [moved] = slides.splice(fromIndex, 1);
            slides.splice(toIndex, 0, moved!);
            // Keep viewing the same slide that was moved
            if (state.currentSlideIndex === fromIndex) {
              state.currentSlideIndex = toIndex;
            } else if (fromIndex < state.currentSlideIndex && toIndex >= state.currentSlideIndex) {
              state.currentSlideIndex -= 1;
            } else if (fromIndex > state.currentSlideIndex && toIndex <= state.currentSlideIndex) {
              state.currentSlideIndex += 1;
            }
            state.isDirty = true;
          }),

        addElement: (slideId, element) =>
          set((state) => {
            assert(state.deck !== null, "No deck loaded");
            const slide = getSlide(state.deck.slides, slideId);
            slide.elements.push(element);
            state.isDirty = true;
          }),

        deleteElement: (slideId, elementId) =>
          set((state) => {
            assert(state.deck !== null, "No deck loaded");
            const slide = getSlide(state.deck.slides, slideId);
            const idx = slide.elements.findIndex((e) => e.id === elementId);
            assert(idx !== -1, `Element ${elementId} not found in slide ${slideId}`);
            slide.elements.splice(idx, 1);
            if (slide.animations) {
              slide.animations = slide.animations.filter(a => a.target !== elementId);
            }
            state.selectedElementIds = state.selectedElementIds.filter(id => id !== elementId);
            state.isDirty = true;
          }),

        duplicateElement: (slideId, elementId) =>
          set((state) => {
            assert(state.deck !== null, "No deck loaded");
            const slide = getSlide(state.deck.slides, slideId);
            const element = slide.elements.find((e) => e.id === elementId);
            assert(element !== undefined, `Element ${elementId} not found in slide ${slideId}`);
            const clone = JSON.parse(JSON.stringify(element)) as SlideElement;
            clone.id = nextElementId();
            clone.position = { x: element.position.x + 20, y: element.position.y + 20 };
            slide.elements.push(clone);
            state.selectedElementIds = [clone.id];
            state.isDirty = true;
          }),

        addAnimation: (slideId, animation) =>
          set((state) => {
            assert(state.deck !== null, "No deck loaded");
            const slide = getSlide(state.deck.slides, slideId);
            if (!slide.animations) slide.animations = [];
            slide.animations.push(animation);
            state.isDirty = true;
          }),

        updateAnimation: (slideId, index, patch) =>
          set((state) => {
            assert(state.deck !== null, "No deck loaded");
            const slide = getSlide(state.deck.slides, slideId);
            assert(slide.animations !== undefined && index >= 0 && index < slide.animations.length, `Animation index ${index} out of bounds`);
            Object.assign(slide.animations[index]!, patch);
            state.isDirty = true;
          }),

        deleteAnimation: (slideId, index) =>
          set((state) => {
            assert(state.deck !== null, "No deck loaded");
            const slide = getSlide(state.deck.slides, slideId);
            assert(slide.animations !== undefined && index >= 0 && index < slide.animations.length, `Animation index ${index} out of bounds`);
            slide.animations.splice(index, 1);
            state.isDirty = true;
          }),

        moveAnimation: (slideId, fromIndex, toIndex) =>
          set((state) => {
            assert(state.deck !== null, "No deck loaded");
            const slide = getSlide(state.deck.slides, slideId);
            assert(slide.animations !== undefined, `Slide ${slideId} has no animations`);
            const anims = slide.animations;
            assert(fromIndex >= 0 && fromIndex < anims.length, `fromIndex ${fromIndex} out of bounds`);
            assert(toIndex >= 0 && toIndex < anims.length, `toIndex ${toIndex} out of bounds`);
            const [moved] = anims.splice(fromIndex, 1);
            anims.splice(toIndex, 0, moved!);
            state.isDirty = true;
          }),

        updateTheme: (patch) =>
          set((state) => {
            assert(state.deck !== null, "No deck loaded");
            const prev = state.deck.theme ?? {};
            const merged: DeckTheme = { ...prev };
            for (const key of Object.keys(patch) as (keyof DeckTheme)[]) {
              merged[key] = { ...prev[key], ...patch[key] } as never;
            }
            state.deck.theme = merged;
            state.isDirty = true;
          }),

        toggleSlideHidden: (slideId) =>
          set((state) => {
            assert(state.deck !== null, "No deck loaded");
            const slide = getSlide(state.deck.slides, slideId);
            slide.hidden = !slide.hidden;
            state.isDirty = true;
          }),

        highlightElements: (ids) => {
          if (highlightTimer) clearTimeout(highlightTimer);
          set((state) => { state.highlightedElementIds = ids; });
          highlightTimer = setTimeout(() => {
            set((state) => { state.highlightedElementIds = []; });
            highlightTimer = null;
          }, 800);
        },

        bringToFront: (slideId, elementId) =>
          set((state) => {
            assert(state.deck !== null, "No deck loaded");
            const slide = getSlide(state.deck.slides, slideId);
            const idx = slide.elements.findIndex((e) => e.id === elementId);
            assert(idx !== -1, `Element ${elementId} not found`);
            if (idx === slide.elements.length - 1) return; // already front
            const [el] = slide.elements.splice(idx, 1);
            slide.elements.push(el!);
            state.isDirty = true;
          }),

        sendToBack: (slideId, elementId) =>
          set((state) => {
            assert(state.deck !== null, "No deck loaded");
            const slide = getSlide(state.deck.slides, slideId);
            const idx = slide.elements.findIndex((e) => e.id === elementId);
            assert(idx !== -1, `Element ${elementId} not found`);
            if (idx === 0) return; // already back
            const [el] = slide.elements.splice(idx, 1);
            slide.elements.unshift(el!);
            state.isDirty = true;
          }),
      })),
      {
        // Only track deck for undo/redo (selectedSlideIds is UI-only state)
        partialize: (state) => ({ deck: state.deck }),
        limit: 50,
        // Skip recording when deck didn't change, OR when either side is null
        // (nullâ†”deck transitions are project lifecycle, not undoable edits)
        equality: (pastState, currentState) =>
          pastState.deck === currentState.deck ||
          pastState.deck === null ||
          currentState.deck === null,
        // Debounce: batch rapid changes (drag, typing) into one undo checkpoint.
        // Captures the state BEFORE the first change in a batch.
        handleSet: (handleSetImpl) => {
          const tryFlush = () => {
            if (isDragging) {
              batchTimeout = setTimeout(tryFlush, 300);
              return;
            }
            handleSetImpl(batchStartState!);
            batchStartState = null;
            batchTimeout = null;
          };
          return (state: Parameters<typeof handleSetImpl>[0]) => {
            if (batchStartState === null) {
              batchStartState = state;
            }
            if (batchTimeout) clearTimeout(batchTimeout);
            batchTimeout = setTimeout(tryFlush, 300);
          };
        },
      },
    ),
  ),
);

// Clear undo history on project switch (open/close are not undoable)
useDeckStore.subscribe(
  (s) => s.currentProject,
  () => {
    if (batchTimeout) {
      clearTimeout(batchTimeout);
      batchTimeout = null;
      batchStartState = null;
    }
    useDeckStore.temporal.getState().clear();
  },
);

// Auto-save: debounce 1s after any mutation
let saveTimeout: ReturnType<typeof setTimeout> | null = null;

useDeckStore.subscribe(
  (s) => s.isDirty,
  (isDirty) => {
    if (!isDirty) return;
    if (saveTimeout) clearTimeout(saveTimeout);
    saveTimeout = setTimeout(() => {
      useDeckStore.getState().saveToDisk();
    }, 1000);
  },
);

